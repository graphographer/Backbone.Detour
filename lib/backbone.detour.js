// Generated by CoffeeScript 1.5.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  Backbone.Detour = (function(_super) {

    __extends(Detour, _super);

    function Detour() {
      Detour.__super__.constructor.apply(this, arguments);
    }

    Detour.prototype.routes = {
      '*path': 'routeHandler'
    };

    Detour.prototype.routeHandler = function(route) {
      var args, parsed, toks,
        _this = this;
      parsed = this.parseRoute(route);
      args = parsed[0];
      toks = parsed[1];
      _.each(this.paramsForRoute, function(pfr) {
        var val, _ref;
        val = args[pfr.name];
        if (((_ref = pfr.type) != null ? _ref.toLowerCase() : void 0) === 'array') {
          val = (val != null ? typeof val.split === "function" ? val.split(',') : void 0 : void 0) || val;
        }
        return args[pfr.name] = val;
      });
      if (!this.previousValues) {
        this.previousValues = {};
      }
      _.each(args, function(v, k) {
        return _this.previousValues[k] = v;
      });
      return this.handleRoute(args, toks);
    };

    Detour.prototype.parseRoute = function(route) {
      var keys, o, tokens, toks, vals, values,
        _this = this;
      if (this.paramsForRoute == null) {
        this.paramsForRoute = [];
        this.expectedTokens = [];
        this.routeOptions();
      }
      keys = [];
      vals = [];
      toks = [];
      if (route) {
        tokens = route.split('/');
        _.each(tokens, function(t) {
          if (__indexOf.call(_this.expectedTokens, t) >= 0) {
            return toks.push(t);
          }
        });
        values = _.without.apply(_, [tokens].concat(__slice.call(toks)));
        _.each(values, function(v, i) {
          return (i % 2 === 0 ? keys : vals).push(v);
        });
      }
      o = _.object(keys, vals);
      _.each(this.paramsForRoute, function(opt) {
        if (opt["default"] != null) {
          if (!o[opt.name]) {
            return o[opt.name] = (typeof opt["default"] === "function" ? opt["default"]() : void 0) || opt["default"];
          }
        }
      });
      return [o, toks];
    };

    Detour.prototype.buildRoute = function(opts) {
      var options, r, required, requiredNotSet, rs, tokens,
        _this = this;
      if (opts == null) {
        opts = {};
      }
      if (opts.tokens) {
        this.previousTokens = opts.tokens;
        tokens = opts.tokens.join('/') + '/';
      } else if (this.previousTokens) {
        tokens = this.previousTokens.join('/') + '/';
      } else {
        tokens = '';
      }
      opts = _.omit(opts, 'tokens');
      options = {};
      if (!this.previousValues) {
        this.previousValues = {};
      }
      _.each(this.paramsForRoute, function(pfr) {
        var comparator, grouped, prevVal, prevVals, pv, val, vals, _i, _len, _ref;
        prevVal = _this.previousValues[pfr.name];
        val = opts[pfr.name] === false ? ((typeof pfr["default"] === "function" ? pfr["default"]() : void 0) || pfr["default"]) || false : opts[pfr.name] ? opts[pfr.name] : prevVal || ((typeof pfr["default"] === "function" ? pfr["default"]() : void 0) || pfr["default"]) || false;
        if ((pfr.squash != null) && val === pfr.squash) {
          val = false;
        }
        if (pfr.group) {
          if (val && !prevVal) {
            grouped = _.filter(_this.paramsForRoute, function(other_pfr) {
              return other_pfr.group === pfr.group && other_pfr.name !== pfr.name;
            });
            _.each(grouped, function(member) {
              opts[member.name] = false;
              return options[member.name] = false;
            });
          }
        }
        if (val && ((_ref = pfr.type) != null ? _ref.toLowerCase() : void 0) === 'array' && pfr.append) {
          vals = val;
          prevVals = prevVal || [];
          for (_i = 0, _len = prevVals.length; _i < _len; _i++) {
            pv = prevVals[_i];
            if (vals.length !== (pfr.appendLimit || 99)) {
              if (pfr.unique) {
                comparator = pfr.comparator || function(a, b) {
                  return a === b;
                };
                if (__indexOf.call(_.map(vals, function(val) {
                  return comparator(val, pv);
                }), true) < 0) {
                  vals.push(pv);
                }
              } else {
                vals.push(pv);
              }
            }
          }
          val = typeof vals.join === "function" ? vals.join(',') : void 0;
        }
        return options[pfr.name] = val;
      });
      required = _.filter(this.paramsForRoute, function(opt) {
        return opt.required;
      });
      requiredNotSet = __indexOf.call(_.map(required, function(req) {
        return options[req.name] || false;
      }), false) >= 0;
      if (requiredNotSet) {
        r = '';
      } else {
        rs = [];
        _.each(this.paramsForRoute, function(pfr) {
          if (options[pfr.name]) {
            return rs.push("" + pfr.name + "/" + (encodeURI(options[pfr.name])));
          }
        });
        r = rs.join("/");
      }
      return tokens + r;
    };

    Detour.prototype.updateRoute = function(opts) {
      return this.navigate(this.buildRoute(opts), {
        trigger: true
      });
    };

    Detour.prototype.optional = function(name, opts) {
      if (opts == null) {
        opts = {};
      }
      opts.name = name;
      return this.paramsForRoute.push(opts);
    };

    Detour.prototype.required = function(name, opts) {
      if (opts == null) {
        opts = {};
      }
      opts.name = name;
      opts.required = true;
      return this.paramsForRoute.push(opts);
    };

    Detour.prototype.tokens = function() {
      var list;
      list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.expectedTokens || (this.expectedTokens = []);
      this.expectedTokens.push(list);
      return this.expectedTokens = _.uniq(_.flatten(this.expectedTokens));
    };

    Detour.prototype.routeOptions = function() {};

    Detour.prototype.handleRoute = function(args) {};

    return Detour;

  })(Backbone.Router);

}).call(this);
